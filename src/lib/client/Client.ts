import { ExecuteableApplication } from '../Execution/ExecuteableApplication'
import { IpAddresses } from '../Network/IpAddresses'
import { ClientGroupExecution } from '../Execution/ClientGroupExecution'
import { Executable } from '../Execution/Executable'
import { ExecutableTree } from '@/types/Clients/ExecutableTree'

/**
 * A client is a remote machine that is connected or has been connected
 * to the service. This is the representation of the actual client aka
 * data that is to be displayed in the application, and saved to storage. This client
 * has nothing to do with networking.
 */
export class Client {
	// The name of the client, provided by the remote client
	private _name: string = 'New client'

	// Unique id of the client, generated by the client to identify, this id should never change when
	// it is first created by the client.
	private _id: string = ''

	// The two different IP addresses for the client
	private _ipAddresses: IpAddresses = {
		ipv4: '',
		ipv6: '',
	}
	// Timestamp (ISOstring) of when the client was first seen/connected
	private _firstSeen: string = ''

	// Timestamp (ISOstring) of when the client last connected
	private _lastSeen: string = ''

	// List of all the avaiable folders that we are allowed
	// to execute application is, provided by the remote client
	private _validExecutionFolders: Array<ExecutableTree> = []

	// List of all the created executable applications for this client
	private _executions: Array<ExecuteableApplication> = new Array()

	// List of all the created group executions for this client
	private _groupExecutions: Array<ClientGroupExecution> = new Array()

	//State flag for connection, true if client is connected
	private _connected: boolean = false

	constructor(name?: string, id?: string) {
		if (name) this.name = name
		if (id) this.id = id
	}

	public get name(): string {
		return this._name
	}

	public set name(v: string) {
		this._name = v
	}

	public get id(): string {
		return this._id
	}

	public set id(v: string) {
		this._id = v
	}

	public get ipAddresses(): IpAddresses {
		return this._ipAddresses
	}

	public set ipAddresses(v: IpAddresses) {
		this._ipAddresses = v
	}

	public get firstSeen(): string {
		return this._firstSeen
	}

	public set firstSeen(v: string) {
		this._firstSeen = v
	}

	public get lastSeen(): string {
		return this._lastSeen
	}

	public set lastSeen(v: string) {
		this._lastSeen = v
	}

	public get validExecutionFolders(): Array<ExecutableTree> {
		return this._validExecutionFolders
	}

	public set validExecutionFolders(v: Array<ExecutableTree>) {
		this._validExecutionFolders = v
	}

	public get executions(): Array<ExecuteableApplication> {
		return this._executions
	}

	public set executions(v: Array<ExecuteableApplication>) {
		this._executions = v
	}

	public get connected(): boolean {
		return this._connected
	}

	public set connected(v: boolean) {
		this._connected = v
	}

	public get groupExecutions(): Array<ClientGroupExecution> {
		return this._groupExecutions
	}

	public addGroupExecution(groupExecution: ClientGroupExecution) {
		this._groupExecutions.push(groupExecution)
	}

	public removeGroupExecutionById(id: string) {
		let i = this.groupExecutions.findIndex(c => c.id == id)
		if (i != -1) this.groupExecutions.splice(i, 1)
	}

	/**
	 * Returns the group execution with the provided id or undefined
	 * if not found
	 * @param id the id of the group execution
	 */
	public getGroupExecutionById(id: string) {
		for (const groupExecution of this.groupExecutions) {
			if (groupExecution.id == id) return groupExecution
		}
	}

	/**
	 * Adds an executable to the a group execution
	 * @param id the if of the group execution
	 * @param executable the executable to remove
	 */
	public addExecutableToGroupExecutionById(
		id: string,
		executable: Executable
	) {
		const gex = this.groupExecutions.find(gex => {
			return gex.id === id
		})
		if (gex) {
			gex.addExecutable(executable)
		}
	}

	/**
	 * Remove an executable from the a group execution
	 * @param id the if of the group execution
	 * @param executable the executable to remove
	 */
	public removeExecutableFromGroupExecutionById(
		id: string,
		executable: Executable
	) {
		const gex = this.groupExecutions.find(gex => {
			return gex.id === id
		})
		if (gex) {
			gex.removeExecutable(executable)
		}
	}

	/**
	 * Returns the executable application, or undefined if it cant find the
	 * executable application.
	 * @param eid the eid of the executable to get
	 */
	public getExecutableApplication(eid: string) {
		return this._executions.find(executeable => {
			return executeable.eid == eid
		})
	}
}
